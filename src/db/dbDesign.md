# Pokemon Database Design

## Entities and attributes
All `id`'s are generated by AUTO-INCREMENT. We treat the same `move` across multiple `generation`'s as separate entries, with the `gen` `introduced` refers to the generation in which the entity was introduced. *PK* stands for primary key, *IFK* stands for identifying foreign key (i.e. it will serve as a component for the primary key of the given entity), and *NFK* stands for non-identifying foreign key.

- `generation`
  - `generation_id`, *PK*
  - `code`, ENUM
- `description`
  - `description_id`, *PK*
  - `text`, TINYTEXT
- `sprite`
  - `sprite_id`, *PK*
  - `url`, TINYTEXT
- `version_group`
  - `generation_id`, *IFK*
  - `version_group_id`, *PK*
  - `code`, ENUM
- `ability`
  - `generation_id`, *IFK*
  - `ability_id`, *PK*
  - `name`, VARCHAR(45)
  - `formatted_name`, VARCHAR(45)
  - `introduced`, *NFK*
  - `affects_item`, TINYINT
- `item`
  - `generation_id`, *IFK*
  - `item_id`, *PK*
  - `name`, VARCHAR(45)
  - `formatted_name`, VARCHAR(45)
  - `introduced`, *NFK*
  - `item_type`, ENUM
- `effect`
  - `effect_id`, *PK*
  - `name`, VARCHAR(45)
  - `formatted_name`, VARCHAR(45)
  - `introduced`, *NFK*
- `usage_method`
  - `usage_method_id`, *PK*
  - `name`, VARCHAR(45)
  - `formatted_name`, VARCHAR(45)
  - `introduced`, *NFK*
- `status`
  - `status_id`, *PK*
  - `name`, VARCHAR(45)
  - `formatted_name`, VARCHAR(45)
- `move`
  - `generation_id`, *IFK*
  - `move_id`, *PK*
  - `name`, VARCHAR(45)
  - `formatted_name`, VARCHAR(45)
  - `power`, SMALLINT
  - `pp`, TINYINT
  - `accuracy`, TINYINT
  - `category`, ENUM
  - `priority`, TINYINT
  - `contact`, TINYINT
  - `target`, ENUM
  - `introduced`, *NFK*
- `stat`
  - `stat_id`, *PK*
  - `name`, ENUM
  - `formatted_name`, VARCHAR(45)
- `ptype`
  - `generation_id`, *IFK*
  - `ptype_id`, *PK*
  - `name`, ENUM
  - `formatted_name`, VARCHAR(45)
  - `introduced`, *NFK*
- `pokemon`
  - `generation_id`, *IFK*
  - `pokemon_id`, *PK*
  - `name`, VARCHAR(45)
  - `formatted_name`, VARCHAR(45)
  - `dex`, SMALLINT
  - `height`, SMALLINT
  - `weight`, SMALLINT
  - `introduced`, *NFK*
  - `hp`, TINYINT
  - `attack`, TINYINT
  - `defense`, TINYINT
  - `special_attack`, TINYINT
  - `special_defense`, TINYINT
  - `speed`, TINYINT

## Relationships

### 1-to-1
- `move`
  - `move_requires_type`, with `ptype`
  - `move_requires_move`, with `ptype`

### 1-to-n
Every entity except `effect`, `status`, `usage_method`, `stat`, `description`, `version_group`, and `sprite` has `generation` as an identifying foreign key. For some 1-to-n relationships, we need to store additional data about the relationship, so we extract them to separate tables.

- `pokemon`
  - `pokemon_evolution`, 1 prevolution to n evolutions
    - Prevolution and evolution as primary keys
    - `method`, TINYTEXT
  - `pokemon_form`, 1 base form to n variants
    - Base Pokemon and variant Pokemon as primary keys
    - `form_type`, ENUM
  - `cosmetic_form`, 1 base form to n cosmetic forms
- `move`
  - `ptype`, 1 type to n moves
  - `usage_method`, 1 usage method to n moves
- `item`
  - `nature_power_type`, 1 type to n items
    - `power`, TINYINT

### m-to-n

The first level indicates the first component of the composite primary key, with the second sublevel indicating the second component, e.g. `pokemon_type` has the primary key for the `pokemon` first (in all cases, we index the opposite order as well, so ultimately this ordering is immaterial).

- `pokemon`
  - `pokemon_type`, with `ptype`
  - `pokemon_move`, with `move`
    - `learn_method`, VARCHAR(4)
  - `pokemon_ability`, with `ability`
    - `slot`, ENUM
- `ptype`
  - `type_matchup`, with `ptype` (a `ptype` entry is even related to itself)
    - `multiplier`, DECIMAL(3,2)
- `move`
  - `move_stat`, with `stat`
    - `stage`, TINYINT
    - `target`, ENUM
    - `chance`, DECIMAL(5,2)
  - `move_causes_status`, with `status`
    - `chance`, DECIMAL(5,2)
  - `move_resists_status`, with `status`
  - `move_effect`, with `effect`
  - `move_requires_pokemon`, with `pokemon`
  - `move_requires_item`, with `item`
- `ability`
  - `ability_resists_type`, with `ptype`
    - `multiplier`, DECIMAL(4,3)
  - `ability_boosts_type`, with `ptype`
    - `multiplier`, DECIMAL(4,3)
  - `ability_stat`, with `stat`
    - `stage`, TINYINT
    - `multiplier`, DECIMAL(4,3)
  - `ability_causes_status`, with `status`
    - `probability`, DECIMAL(4,3)
  - `ability_resists_status`, with `status`
  - `ability_effect`, with `effect`
  - `ability_resists_usage_method`, with `usage_method`
    - `multiplier`, DECIMAL(4,3)
  - `ability_boosts_usage_method`, with `usage_method`
    - `multiplier`, DECIMAL(4,3)
- `item`
  - `item_requires_pokemon`, with `pokemon`
  - `item_boosts_type`, with `ptype`
    - `multiplier`, DECIMAL(4,3)
  - `item_resists_type`, with `ptype`
    - `multiplier`, DECIMAL(4,3)
  - `item_resists_usage_method`, with `usage_method`
    - `multiplier`, DECIMAL(4,3)
  - `item_modifies_stat`, with `stat`
    - `stage`, TINYINT
    - `multiplier`, DECIMAL(4,3)
  - `item_causes_status`, with `status`
  - `item_resists_status`, with `status`
- `version_group`
  - `version_group_description`, with `description`
  - `version_group_sprite`, with `sprite`

### Three-fold relationships
Since `description`'s and `sprite`'s often depend on `version_group` as opposed to `generation`, in contrast with most entities staying the same across `version_group`'s while changing across `generation`'s, their relationships with the other entities are more complicated.

For example, each `ability` can have multiple `description`'s across `version_group`'s within the same `generation`, and the same `description` can apply to different `generation`'s of the same `ability`, giving an m-to-n relationship. Moreover, this relationship has the `version_group` as a foreign key. The primary key of the `ability` (which consists in part of the primary key for the corresponding `generation`), the primary key of the `description`, and the primary key of the `version_group` together make up the primary key for a given row in this relationship.

The following tables have this relationship structure:

- `description`
  - `description_ability`
  - `description_move`
  - `description_item`
- `sprite`
  - `sprite_pokemon`
  - `sprite_item`

The order in which we choose our primary key matters, since at the moment it seems relatively pointless to index on all possible orderings of the three primary keys. For example, concerning `description`, the most common task by far should be, given an entity with a description, e.g. an `ability`, and `version_group`, find the appropriate description. Indeed, one usually wouldn't ask, "given this `description`, what's the corresponding `ability`," but rather "given this `ability`, what's the corresponding `description`?" Thus, `ability`, `move`, `item`, or `pokemon` should come first. One also usually wouldn't ask "given a `description`, what are the `version_group`'s to which it belongs," but rather they would select the given `version_group`, at which point they'd be left with one description.

All of this is to say that `description` should probably come last in the composite primary key. In the case of finding the description for a given entity (`ability`, `move`, etc.), one would know the entity beforehand, thus they should search by that entity first, rather than select a version group and then find the entity within that version group. Thus, the order should be, e.g. `(ability, version_group, description)`. The same logic applies to sprites too. 

As always, this will be subject to how users actually want to query the database, but this ordering makes the most sense to start with.

## Indices

To facilitate querying by `generation`, which would be the most important query for teambuilders, the composite primary keys which consist in part of a `generation` foreign key should definitely have that part first, e.g. `PRIMARY KEY (generation_id, pokemon_id)`, in order to facilitate querying by generation. On the other hand, since one may be interested in how a given entity changes across generations, we'll index on the opposite ordering, e.g. `(pokemon_id, generation_id)`.

For searching by text, we index on `formatted_name` for most entities. To quickly determine all the `pokemon`, `move`'s, etc. a given generation introduced, we index on `introduced` for most entities as well.

### Indices for entities

In addition, we have the following indices (one would usually be selecting an entity from a given generation, in which case, we include `gen_id` first in the following indices). We list them in order of importance (so that, if it becomes too costly to maintain all the indices, we'll choose to drop the latter ones first).

- `pokemon`
  - `(gen_id, formatted_name)`
  - `introduced`
  - `(gen_id, dex, introduced)`; for sorting by Dex number and then sorting forms using `introduced`.
  - `(gen_id, speed)`; for quickly determining Speed tiers.
  - `(gen_id, hp, defense)`; for sorting by survivability against a Physical `move`. `hp` is relevant for other calculations as well independently of `defense` (e.g. against fixed damage `moves`), but `defense` is almost almost always used in the context of surviving `moves`, in which case `hp` is relevant too. In either case, the `gen_id` is also relevant.
  - `(gen_id, hp, special_defense)`; same reasoning as above but for surviving a Special `move`.
  - `(gen_id, attack)`; for sorting by ability to deal damage with Physical `move`'s.
  - `(gen_id, defense)`; same as above but for Special `move`'s.
- `move`
  - `(gen_id, formatted_name)`
  - `introduced`
  - `(gen_id, ptype)`
  - `(gen_id, power)`; for damage calculations.
  - `(gen_id, category)`; often want to classify by Physical, Special, Status.
- `item`
  - `(gen_id, formatted_name)`
  - `introduced`
  - `(gen_id, item_type)`
- `ability`
  - `(gen_id, formatted_name)`
  - `introduced`

### Indices and primary key order for relation tables

For all m-to-n relationships, we index the opposite ordering of the composite primary keys. We discussed the primary key order/indexing for the three-fold relationships in that section; suffice it to say that we do not for the add additional indices to that relationship.
